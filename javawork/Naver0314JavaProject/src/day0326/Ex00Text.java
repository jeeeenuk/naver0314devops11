package day0326;
/*
    다형성이란 ?
    동일한 메시지(메서드 호출)에 대해 서로 다른 객체가 다르게 동작하는 능력(message polymorphism)을 뜻한다.
    다형성은 한가지 타입 또는 인터페이스를 여러 개의 구현체가 가질 수 있도록 함으로써 유연하고 확장 가능한 코드를 작설할 수 있게 해준다.

    1. 업케스팅(Upcasting) :  자식 클래스의 인스턴스를 부모 클래스의 참조 변수로 참조하는 것을 말한다.
                            부모 클래스의 참조 변수를 통해 자식 클래스의 객체에 접근할 수 있다.
                            업캐스팅을 통해 여러개의 자식 클래스를 하나의 부모 클래스 타입으로 관리할 수 있다.
    2. 메서드 오버라이딩 (Method Overriding) :  자식 클래스에서 부모 클래스의 메서드를 재정의하여 자식 클래스에서 특화된 구현을 제공한다.
                                            부모 클래ㅡ의 메서드를 자식 클래스에서 동일한 이름으로 재정의하면, 실행 시에는 실제 객체의
                                            타입에 맞는 메서드가 호출된다.
    3. 다형적 변수(Polymorphic Variables) : 부모 클래스의 참조 변수를 사용하여 여러 자식 클래스의 객체를 참조할 수 있다.
                                          이렇게 다형적 변수를 사용하면 실행 시에 실제 객체의 타입에 따라 다른 동작을 수행할 수 있다.

    Interface 에서는 final 또는 abstract 를 붙여서 사용하지 않는다. (생략 가능) !!
    이유는 Interface 에 들어오는 값들은 무조건 상수와 추상메서드로 등록 되기 때문이다.
    Interface 의 경우 음식점의 메뉴판과 같다고 표현한다. 메뉴판을 보고 고객이 원하는 음식을 요청하게 되는데, 이때 메뉴판 자체가 음식을 주는게 아니기 때문
    ** 구현 가능한 목록을 "나열" 만 해준다.

    [접근제한] interface [인터페이스명]{
        상수; (final)
        추상메서드; (abstract)
    }

    인터페이스간의 상속 : class 간의 상속과 다르게 실제 구현력이 없는 인터페이스들 간의 상속에서는 "다중 상속" 이 가능하다 !

    [접근제한] interface [인터페이스명] implements 부모인터페이스명1, 부모인터페이스명2, ... {
        상수; (final)
        추상메서드; (abstract)
    }
    --------------------------------------------------------------------------------------------------
    내부 클래스의 종류와 사용 방법
    Member : 멤버 변수나 멤버 메서드들과 같이 클래스가 정의된 경우에 사용한다.
    Local : 특정한 메서드 내에 클래스가 정의된 경우에 사용한다.
    Static : static 변수(클래스 변수)와 같이 클래스가 static 으로 선언된 경우에 사용한다.
    Anonymous : 참조할 수 잇는 이름이 없는 경우에 사용한다.
    --------------------------------------------------------------------------------------------------
    예외 처리 !
    1. Checked Exception : 컴파일 시점에 체크되는 예외이다. 이러한 예외는 반드시 try-catch 블록으로 처리하거나, 메소드를 throws 키워드를 사용하여
                           호출자에게 예외 처리의 책임을 전달해야 한다. 예)IOException, SQLException
    2. Unchecked Exception : 런타임 시점에 발생하는 예외이다. 이러한 예외는 프로그래머의 실수로 발생하는 경우가 많으며, 명시적인 예외 처리를 강제하지
                             않는다. 예)NullPointerException, ArithmeticException

    예외 (Exception) : 가벼운 오류이며 프로그램적으로 처리한다.
    오류 (Error) : 치명적 오류이며 JVM 에 의존하여 처리한다.

    문제가 발생함을 알 수 있으나 오류를 발생시키지 않고 넘기도록 할 때 사용한다.
    예를들어 Ex13Exception 문제의 경우 String 으로 값을 받아 x를 받을 경우 프로그램을 종료, 숫자가 들어올 경우 그 두 문자열을 int 로 형변환 하여
    두 수를 더한 값을 출력해주는 코드이다. Scanner 를 사용하여 키보드 입력값을 받았을 때 만약 숫자가 아닌 문자열 (a, b ... 등)이 들어올 경우
    NumberFormatException 의 오류가 나오게 된다. 이 때 코드의 문제는 없고 외부에서 받는 입력값에 문제가 있는 경우이기 때문에 "예외" 처리를 해준다.

    [접근제한][반환형][메서드명](인자 1, ...) throws 예외클래스1, ...{
        try { 예외가 발생할 가능성이 높은 코드를 포함 , 예외가 발생하였을 경우 catch 블록으로 전달
        } catch (예외 1) {
            예외 1이 발생했을 경우 실행시킬 구문
        } catch (예외 2) {
            예외 2가 발생했을 경우 실행시킬 구문
        } finally {
            catch 에서 오류가 발생하던 말던 무조건 실행 !
        }
    }
 */
